#+HTML_HEAD: <style>pre.src {background-color: #303030; color: #e5e5e5;} </style>
#+HTML_HEAD_EXTRA: <style> blockquote {background:#EEEEEE; padding: 3px 13px}</style>
#+HTML_HEAD: <style>pre.src {background-color: #303030; color: #e5e5e5;} </style>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-style.css"/>
#+TITLE: The Package Handoff Library
* Introduction

The following Euclidean Steiner-Tree question was posed in CG group while discussing
a recent paper by Craig Tovey [fn:1]: 

[fn:1] That paper gave heuristics for transporting multiple packages from their sources
to destinations along a graph with $r$ co-ordinating carrier robots.


#+BEGIN_quote
There are $m$ mobile carrier-robots initially located at $\{(x^{r}_j, y^{r}_j)\}_{j=1}^m \subseteq \mathbb{R}^2$.
For each $j$, where $1 \leq j \leq m$, robot $r_j$ is able to move in any direction with a maximum speed $v_j$.
If two robots meet at a point in the course of their motion, they can exchange an arbitrary number of
items they each carry. For simplicity, assume that each of the $m$ robots has infinite fuel and
an infinite weight-carrying capacity.

If you are given $n$ stationary packages tagged $p_1, p_2, \ldots p_n$ located respectively at
$\{(x^{s}_i, y^{s}_i)\}_{i=1}^n$ all of which must get to their destinations $\{(x^{t}_i, y^{t}_i)\}_{i=1}^n$
using the $m$ robots, how can you construct a schedule for the robots to transport
all packages to their destinations "quickly" ?
#+END_quote

We get different cost criteria based on the interpretation of "quick": min-sum. or min-max. The /*min-sum*/ problem 
asks to minimize the sum of the travel times of all packages, while the /*min-max*/ requires the maximum of their 
delivery-times to be minimized.

A real world instance of this problem is when a taxi-service must co-ordinate
its fleet of cabs to transport passengers located at different points on the map, 
to their destinations.

Here are a few variations on this problem's theme.  

- What if only one package needs to be transported i.e. $n=1$ ? In this case, min-sum and
  min-max objective functions are equal. 
- What if $n=1$ /and/ the package must move along a straight-line from its source all the way
 to its destination. This is also an interesting question for the multiple-robot case.
  i.e. all packages must move along a straight line from their origin to their destination.
- What if $n=2$?
- What if every robot could travel with the same maximum speed $v_j=V$ but has only limited fuel?
  Two additional sub-constraints might be of interest.
   - What if every robot is constrained to move back into its original position after it does
     all its handoffs as required by the schedule.
   - What if a robot is allowed to move only along the horizontal and vertical directions?

* Theory
* Experiments

I've created a private Github repository, *[[https://github.com/gtelang/packagehandoff][packagehandoff]]* ,which contains code for experimenting
with various heuristics for solving package-handoff problems. It also has a wiki 
containing a motley collection of checklists, todos, braindumps and notes-to-self being made while 
designing library.

I plan to implement the code using the Haskell platform, with occasional calls to C++ libraries.

The main Haskell and C/C++ libraries to be used by the library are
0. Reactive Banana
1. CGAL (via C-wrappers)
2. GSL  (via C-wrappers)
3. Diagrams (for its computations): (it has many geometric primitives like the left-turn test)
4. Jon Shewchuk's geometric predicates (directly via the FFI)
5. Cplex-interface (for optimization)
6. GLPK-interface  (for linear programming)
7. FGL (native Haskell), iGraph and the BGL( both with C bindings via FFI)
8. GeoSteiner (C bindings via the FFI) (for Steiner Tree computations)
9. Gloss (for interactive input)

Different heuristics for both single and multi-package will be implemented atop the interactive system
outlined in the next section. 

** Specification

The executable starts in one of two modes. 
#+BEGIN_SRC sh
<prompt> ./main --variable-velocity # Fuel = ∞ ∀ robots,
<prompt> ./main --bounded-fuel # Max-Velocity = 1.0 ∀ robots
#+END_SRC
Depending on the modes, the appropriate algorithms are activated.  Once the schedule 
has been computed, it is written out as a  YAML file, then rendered or animated. [fn:2]

[fn:2] A benign bug in Gloss (with The GLUT backend) terminates the program after 
closing the canvas (but see [[http://stackoverflow.com/a/39622163/505306][this]] for a possible solution!). 


Data is inserted into the canvas as follows. 
- Left-mouse button *dbl-click* :: @@html:<font color = "red">@@ Insert Robots   @@html:</font>@@
- Right-mouse button *dbl-click* :: @@html:<font color = "red">@@ Insert Packages    @@html:</font>@@
- Scroll-wheel ::  
    - @@html:<font color = "red">@@Adjust fuel (disk size) @@html:</font>@@  
    - @@html:<font color = "red">@@Adjust speed (disk color on a spectrum) @@html:</font>@@
- Right-mouse button *single-click* :: 
     When done on robots/packages select for editing
     - Left-mouse *drag*  :: Translate robots/packages as a group
     - Scroll-Wheel :: Adjust group properties in increments
     - Delete :: Delete group
                 
I will be using all of Diagrams' inbuilt data-types for things such as points, 
vectors, planes and other things. I might have to use gloss3d/OpenGL/three.js(via GHCJS)
for visualizing problems like these in 3d.

For more sophisticated algorithms, I shall be using CGAL via the C-FFI. For simpler ones, 
Diagrams and Boost::Geometry should suffice. Examples of algorithms in Boost::Geometry are: 
   - Area and Perimeter
   - Centroid
   - Convex Hull
   - Axis Aligned Bounding Box etc.
   - Unions and [[http://www.boost.org/doc/libs/1_61_0/libs/geometry/doc/html/geometry/reference/algorithms/intersection.html][Intersections]] of two geometries, like polygons! 
   The full list is available [[http://www.boost.org/doc/libs/1_61_0/libs/geometry/doc/html/geometry/reference/algorithms.html][here]].

Much of BoostGeometry code is based on the notion of C++ concepts, which are very 
similar to Haskell's typeclasses.  
** Layout   
The code will consist of the following files. 

- Main.hs ::  All setup, profiling work goes here. When the library starts
              maturing, I'll make literate .org files for setting up different experiments. 
              The tangled main.hs files will go into  /app/. 
 
- PackageHandoffUtilities.hs :: Common functions, Typeclasses, Event handlers, and other plumbing

- ProbX.hs ::  Variants we will be trying to solve are:
     - OnePackageVariableVelocity.hs    (∞ fuel)
     - MultiPackageVariableVelocity.hs  (∞ fuel)
     - OnePackageBoundedFuel.hs         (Vel=1.0)
     - MultiPackageBoundedFuel.hs       (Vel=1.0)

** Source Code [fn:3]
[fn:3] For the /Main.hs/ files, have a look inside *codeHaskell-pho/app*


*** PackageHandoffPrelude.hs
*PackageHandoffPrelude.hs* contains data-structures and routines common to all package-handoff 
variants. This section describes the code therein. First, import necessary libraries and make 
some descriptive type-synonyms. 
 
#+BEGIN_SRC haskell :tangle codeHaskell-pho/src/PackageHandoffPrelude.hs
  {- | Common Data-Structures and Functions. -}

  {-# LANGUAGE NoMonomorphismRestriction #-}
  module PackageHandoffPrelude where
  import Diagrams.Prelude
  import qualified Data.Map as Map
  -- TODO: Use Liquid Haskell to enforce the commented constraints at the type level
  type Speed    = Double -- | ∈ [0,1]
  type Fuel     = Double -- | ≥ 0
  type Time     = Double -- | ≥ 0
  type PkgIndex = Int    -- | ≥ 0 
#+END_SRC

The *Package* data-type stores the Cartesian co-ordinates of the *source* and *target* points 
of a package.
#+BEGIN_SRC haskell  :tangle codeHaskell-pho/src/PackageHandoffPrelude.hs
  data Package = Package { source :: Point V2 Double,
                           target :: Point V2 Double 
                         } deriving (Show)
#+END_SRC

Each robot will travel along a _piece-wise linear_ curve, its vertices being sources/destinations of the packages 
and the rendezvous points where package-handoffs must occur. With that in mind, it is natural to represent the route 
for a single robot, as a *Trajectory*, which is a collection of *Link*'s and the global schedule being a collection 
of *Trajectory* s. Each *Link* is like a arrow in $\mathbb{R}^2$ tagged data such as which packages travelled along 
that link, and a description of the package-exchanges that must take place at the link's *head*. 

What is unique to each world will be the nature of the robots and consequently the nature of the schedule they 
generate: a schedule consists of a collection of robot trajectories. 

#+BEGIN_SRC haskell :tangle codeHaskell-pho/src/PackageHandoffPrelude.hs
  -- | Every world comes with its own kind of robot and link (see below)
  class Robot = Robot { initPosition :: Point V2 Double, 
                        schedule :: Schedule -- Starts out as empty for everyone. Empty schedule corresponds to nothing to do.
                      } deriving (Show)

  -- | Schedule for a collection of robots. In one-one correspondence with the robots array.
  type Schedule    = [ Trajectory ] -- TODO Need to ask if this gets a type-class constraint too.

  -- | Schedule for a single robot. 
  data Trajectory  = Trajectory [ Link w ]  -- TODO This gets a typeclass constraint depending on the world type used. Should we use Trails from Diagrams?
                                            -- you might also want to create a function to extract a diagrams trajectory using lenses across all links. 
                                            -- You may need to make this into an additive type. Where the data-constructor indicates an open/closed path
                                            -- These last two types are now going to be important. 
   -- | An element of a trajectory. Every world generates its own type of link. 
   --   Think of the link as an arrow with a definite position in space.  
  class Link w = Link -- TODO This becomes a type-class too. Store both the start and tail, but extract only the head.
                { head              :: Point V2 Double, -- ^ The rendezvous point
                  waitTime          :: Time       ,     -- ^ Time of waiting at the head
      
                  -- These three items will get different implementations based on single/package/multipackage world. 
                  -- Infact, it is possible that the exchange operation between two robots will have to bde described 
                  -- in special terms for each world. e.g. in the one-package case, the robot will probably hand off 
                  -- its package only at the trajectory end after which it will either stop or return to its end point. 
                  -- This will be important in those Delaunay triangulation  like schemes which Joe mentioned.
                  inTransitPackages :: [PkgIndex] ,     -- ^ List of packages carried while moving to head
                  givePackagesTo    :: Map.Map PkgIndex [PkgIndex],-- ^ Give packages to specified robots 
                  takePackagesFrom  :: Map.Map PkgIndex [PkgIndex] -- ^ Take packages from specified robots
                 } deriving (Show) 
 #+END_SRC

Finally, the *World* class stores information about the robots and packages obtained from 
input source (e.g. the Gloss canvas or a YAML file)  
#+BEGIN_SRC haskell :tangle codeHaskell-pho/src/PackageHandoffPrelude.hs
  -- Give it a good implementation of `show` also for a clean description of 
  -- the world's constituents, which can possibly be serialized using YAML
  data World = World { robots      :: [Robot]  ,    
                       packages    :: [Package]
                      } deriving (Show) -- Information about the world is contained in the type-class constraint of robots. Gloss functions will actt
                                        -- on this world.
#+END_SRC

Note that *World* knows _nothing_ about the input source from which it came: 
it might have been a file, or it could have been inserted via a Gloss or a Diagrams canvas.  
Keeping the algorithmic and the input/output codes strictly decoupled is essential for making 
the code more modular. 

It also doesn't know anything about the current-time on the clock. /That/ clocking, if needed, will 
be taken care by a wrapper data-structure used by the visualization/animation routines of diagrams or gloss.

*** OnePackageVariableVelocity.hs
#+BEGIN_SRC haskell :tangle  codeHaskell-pho/src/OnePackageVariableVelocity.hs
 {- | Contains data-structures and scheduling algorithms for 
      routing a single package from source to destination, using carrier-
      robots with varying velocity. The fuel for each robot is assumed to be +∞ -}

{-# LANGUAGE UnicodeSyntax #-}
{-# LANGUAGE NoMonomorphismRestriction #-}
 module SinglePackageRouting where

 import Diagrams.Prelude
 import qualified Data.List as List
 import qualified Data.Map  as Map
 import qualified Data.Set  as Set
 import qualified Data.Function as Function
 import Control.Monad
 import Data.Monoid 
 import Data.Colour.Palette.BrewerSet
 import Graphics.Gloss
 import Graphics.Gloss.Interface.Pure.Game
#+END_SRC
