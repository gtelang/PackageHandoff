#+HTML_HEAD: <style>pre.src {background-color: #303030; color: #e5e5e5;} </style>
#+HTML_HEAD_EXTRA: <style> blockquote {background:#EEEEEE; padding: 3px 13px}</style>
#+HTML_HEAD: <style>pre.src {background-color: #303030; color: #e5e5e5;} </style>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-style.css"/>
#+INFOJS_OPT: path:org-info.js view:info toc:nil

#+TITLE: Package Handoff

* Introduction

An interesting Euclidean Steiner-Tree like question was posed by Prof. Mitchell while discussing
a paper by Craig Tovey giving heuristics for transporting multiple packages from their sources
to destinations along a graph with $r$ co-ordinating carrier robots.

#+BEGIN_quote
There are $m$ mobile carrier-robots located initially at $\{(x^{r}_j, y^{r}_j)\}_{j=1}^m \subseteq \mathbb{R}^2$.
For each $j$, where $1 \leq j \leq m$, robot $r_j$ is able to move in any direction with a maximum speed $v_j$.
If two robots meet at a point in the course of their motion, they can exchange an arbitrary number of
items they each carry. For simplicity, each of the $m$ robots can be assumed to have infinite fuel and
an infinite weight-carrying capacity.

If you are given $n$ stationary packages tagged $p_1, p_2, \ldots p_n$ located respectively at
$\{(x^{s}_i, y^{s}_i)\}_{i=1}^n$ all of which must get to their destinations $\{(x^{t}_i, y^{t}_i)\}_{i=1}^n$
using the $m$ robots, how can you construct a schedule for the robots to transport
all packages to their destinations "quickly" ?
#+END_quote

Depending on the interpretation of "quick", we get different cost criteria. e.g. /*min-sum*/:
the sum of the travel times of the packages and /*min-max*/: the time required for the last package
to get to its destination.

A nice real world instance of this problem is one where a taxi-service must co-ordinate
its fleet of cabs to transport passengers located at different points on the map, to
their destinations.

Here are a few variants or special cases of the above problem that might be of independent interest.

- What if only one package needs to be transported i.e. $n=1$ ? In this case, min-sum and
  min-max yield the same cost function.
- What if $n=1$ /and/ the package must move along a straight-line from its source all the way
 to its destination. This is also an interesting question for the multiple-robot case.
  i.e. all packages must move along a straight line from their origin to their destination.
- What if $n=2$?
- What if every robot could travel with the same maximum speed $v_j=V$ but has only limited fuel.
  Two additional sub-constraints might be of interest.
   - What if every robot is constrained to move back into its original position after it does
     all its handoffs as required by the schedule.
   - What if a robot is allowed to move only along the horizontal and vertical directions?
- Is there a continuous version of this problem? By that I mean, could robots be thought of
  as distributed uniformly throughout the domain?

* Theory
* Experiments

I've created a Github repository, *[[https://github.com/gtelang/packagehandoff][packagehandoff]]* ,which contains the Haskell code for experimenting
with various heuristics for solving package-handoff problems. That repository also contains a wiki 
containing a motley collection of checklists, todos, braindumps and notes-to-self being made while 
designing library.

The base of the code is similar to that of Pulleys and r-Gather in Python. 
Here I plan to principally use Haskell. Besides Haskell also some really interesting libraries like quickcheck, 
reactive-banana, gloss, Diagrams, lenses, the FGL and GSL bindings, the parallelism on offer and of course as 
a design langauge for algorithms using its type-system. Besides, gloss apparently performs extremely well under 
threading. 

The most important libraries for performing geometric computations will be
0. Reactive Banana
1. CGAL (via C-wrappers)
2. GSL  (via C-wrappers)
3. Diagrams (for its computations): (it does have the left turn thing)
4. Shewchuk's predicates (directly via the FFI)
5. Cplex-interface (for optimization)
6. GLPK-interface  (for linear programming)
7. FGL (native Haskell), iGraph and the BGL( both with C bindings via FFI)
8. GeoSteiner (C bindings via the FFI)
9. Liquid-Haskell and the Dependent Types Extension (for stronger types)

Different heuristics for both single and multi-package routine will be implemented atop the following interactive system
outline in the next section. 

**  Specification

The executable is started in one of two modes. 

#+BEGIN_SRC sh
<prompt> ./main --variable-velocity # Fuel = ∞ ∀ robots,
<prompt> ./main --bounded-fuel # Max-Velocity = 1.0 ∀ robots
#+END_SRC
Depending on the modes, the appropriate algorithms are activated.  Once the schedule 
has been computed, it is written out as a  YAML file, then rendered or animated. [fn:1]

[fn:1] Because of a stupid bug in gloss (with The GLUT backend) where it 
terminates the program after pressing *Esc* (but see [[http://stackoverflow.com/a/39622163/505306][this]] for a possible solution!),  
you will have to animate the robot-schedule last.


Data is inserted into the canvas as follows. 
- Left-mouse button *dbl-click* :: @@html:<font color = "red">@@ Insert Robots   @@html:</font>@@
- Right-mouse button *dbl-click* :: @@html:<font color = "red">@@ Insert Packages    @@html:</font>@@
- Scroll-wheel ::  
    - @@html:<font color = "red">@@Adjust fuel (disk size) @@html:</font>@@  
    - @@html:<font color = "red">@@Adjust speed (disk color on a spectrum) @@html:</font>@@
- Right-mouse button *single-click* :: 
     When done on robots/packages select for editing
     - Left-mouse *drag*  :: Translate robots/packages as a group
     - Scroll-Wheel :: Adjust group properties in increments
     - Delete :: Delete group
                 
I will be using all of Diagrams' inbuilt data-types for things such as points, 
vectors, planes and other things. I might have to use gloss3d/OpenGL/three.js(via GHCJS)
for visualizing problems like these in 3d.

For many sophisticated algorithms, I shall be using CGAL. For the simpler ones, we have Diagrams 
and Boost::Geometry. Examples of algorithms available in the latter are: 
   - Area and Perimeter
   - Centroid
   - Convex Hull
   - Axis Aligned Bounding Box etc.
   - Unions and [[http://www.boost.org/doc/libs/1_61_0/libs/geometry/doc/html/geometry/reference/algorithms/intersection.html][Intersections]] of two geometries, like polygons! 
   The full list of algorithms in Boost::Geometry is available [[http://www.boost.org/doc/libs/1_61_0/libs/geometry/doc/html/geometry/reference/algorithms.html][here]]:

Much of BoostGeometry code is based on the notion of C++ concepts, which are very 
similar to Haskell's typeclasses. 
** Layout   
The layout of the code files will be as follows:

- Main.hs ::  All setup, profiling work goes here. When your program starts
              maturing, start having independent org files for the main.hs files
              which setup different sorts of experiments. This imports algorithmX
              and calls it via play in addition to any other profiling steps.
              These go into the /app/ folder. 
 
- PackageHandoffUtilities.hs :: Common functions, typeclasses, event handlers etc.

- ProbX.hs ::  Variants we will be trying to solve are:
     - OnePackageVariableVelocity.hs 
     - MultiPackageVariableVelocity.hs
     - OnePackageBoundedFuel.hs
     - MultiPackageBoundedFuel.hs

  These four files will be instantiating typeclasses for robots and implementing 
  approximation algorithms for min-sum and min-max variants.

** Library Source Code
Each subsection here describes the source-code inside the file given by the subsection heading. 
For the /Main.hs/ files, have a look inside *codeHaskell-pho/app*
*** PackageHandoffPrelude.hs
:PROPERTIES:
:TANGLE: codeHaskell-pho/src/PackageHandoffPrelude.hs
:END:

*PackageHandoffPrelude.hs* contains data-structures and routines common to all package-handoff 
variants. This section describes the code therein. First, import necessary libraries and make 
some descriptive type-synonyms. 
 
#+BEGIN_SRC haskell :tangle codeHaskell-pho/src/PackageHandoffPrelude.hs
  -- | Common Data-Structures and Functions.

  {-# LANGUAGE NoMonomorphismRestriction #-}
  module PackageHandoffPrelude where
  import Diagrams.Prelude
  import qualified Data.Map as Map
  -- TODO: Use Liquid Haskell to enforce ≥ 0 at the type level
  type Speed    = Double -- | ≥ 0
  type Fuel     = Double -- | ≥ 0
  type Time     = Double -- | ≥ 0
  type PkgIndex = Int    -- | ≥ 0 
#+END_SRC

The *Robot* data-type stores information about a single robot such as its positions at time $t=0$
maximum speed, fuel capacity and other input-data. 
#+BEGIN_SRC haskell :tangle codeHaskell-pho/src/PackageHandoffPrelude.hs
  data Robot = Robot { initPosition :: Point V2 Double, 
                       maxSpeed     :: Speed          ,
                       maxFuel      :: Fuel 
                      } deriving (Show)
#+END_SRC

The *Package* data-type stores the Cartesian co-ordinates of the *source* and *target* points 
of a package.
#+BEGIN_SRC haskell  :tangle codeHaskell-pho/src/PackageHandoffPrelude.hs
  data Package = Package { source :: Point V2 Double,
                           target :: Point V2 Double 
                         } deriving (Show)
#+END_SRC

The *World* data-type stores information about the robots and packages obtained from 
input source (e.g. the Gloss canvas or a YAML file)  
#+BEGIN_SRC haskell :tangle codeHaskell-pho/src/PackageHandoffPrelude.hs
  data World = World { robots      :: [Robot]  ,    
                       packages    :: [Package]    
                     } deriving (Show)
#+END_SRC

Note that *World* knows _nothing_ about the input source from which it came: 
it might have been a file, or it could have been inserted via a Gloss or a Diagrams canvas.  
Keeping the algorithmic and the input/output codes strictly decoupled is essential for making 
the code more modular. Besides, it is apossible that using javascript libraries via GHCJS might 
be an excellent option in the future for creating more sophisticated animations (e.g. using D3 and three.js)
and possibly even for three dimensions.

It also doesn't know anything about the time on the clock. /That/ clocking will be taken care 
by a wrapper data-structure used by the visualization/animation routines of diagrams or gloss.

**** *_Gloss Canvas IO_* 
Now we will need to connect the world to a Gloss canvas. The following data-structures
will be used by event-handlers which themselves are wrappers around the algorithmic code. 

#+BEGIN_SRC haskell  :tangle codeHaskell-pho/src/PackageHandoffPrelude.hs
-- | State of the Gloss canvas
data GlossCanvas = GlossCanvas{ currentMode :: Mode, 
                                world       :: World, 
                                schedule    :: Schedule
                              } deriving (Show)   
#+END_SRC

*Mode* in the snippet above refers to the following type. The GlossCanvas is always in one of four states(modes) 
described in the *Mode* data-type above. Depending on the current mode of the canvas, it responds differently to 
mouse and key-press events. To switch between the 4 modes use the *r,f,p,a* keys. To clear the canvas and reset the 
world state to empty, use *X* (Note the caps)

#+BEGIN_SRC haskell :tangle codeHaskell-pho/src/PackageHandoffPrelude.hs
 -- | The Gloss Canvas is always in one of four modes
  data Mode =   RobotInput    -- ^ Insert Robots onto Canvas        'r 
              | FuelInput     -- ^ Adjust the fuel for each robot.  'f'
              | PackageInput  -- ^ Insert Packages onto the Canvas. 'p'
              | AlgoInput     -- ^ Choose scheduling algorithm.     'a'
              deriving (Show, Eq)
#+END_SRC

Each robot will travel along a _piece-wise linear_ curve, its vertices being sources/destinations of the packages 
and the rendezvous points where package-handoffs must occur. With that in mind, it is natural to represent the route 
for a single robot, as a *Trajectory*, which is a collection of *Link*'s and the global schedule being a collection 
of *Trajectory* s. Each *Link* is like a arrow in $\mathbb{R}^2$ tagged data such as which packages travelled along 
that link, and a description of the package-exchanges that must take place at the link's *head*. 

#+BEGIN_SRC haskell :tangle codeHaskell-pho/src/PackageHandoffPrelude.hs
  -- | Schedule for a single robot.
  type Trajectory  = [ Link ] 

  -- | Schedule for a collection of robots
  type Schedule    = [ Trajectory ] 

  -- | An element of a trajectory
  data Link = Link 
             { head :: Point V2 Double         , -- ^ Rendezvous or pick-up point 
               waitTime          :: Time       ,-- ^ Time of waiting at the head
               inTransitPackages :: [PkgIndex] ,-- ^ List of packages carried while moving to head
               givePackagesTo    :: Map.Map PkgIndex [PkgIndex],-- ^ Give packages to specified robots 
               takePackagesFrom  :: Map.Map PkgIndex [PkgIndex] -- ^ Take packages from specified robots
              } deriving (Show)
#+END_SRC

**** *_Disk File IO_* 
*** SinglePackageRouting.hs
#+BEGIN_SRC haskell :tangle  codeHaskell-pho/src/SinglePackageRouting.hs
{-# LANGUAGE UnicodeSyntax #-}
{-# LANGUAGE NoMonomorphismRestriction #-}

 {- | This module contains scheduling algorithms and data-structures for 
      routing a single package from point A to point B, where the carrier-
      robots have varying velocity and possibly limited fuel.
 -}

 module SinglePackageRouting where

 import Diagrams.Prelude

 import qualified Data.List as List
 import qualified Data.Map  as Map
 import qualified Data.Set  as Set
 import qualified Data.Function as Function
 import Control.Monad
 import Data.Monoid 

 import Data.Colour.Palette.BrewerSet
 import Graphics.Gloss
 import Graphics.Gloss.Interface.Pure.Game

#+END_SRC
