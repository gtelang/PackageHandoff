-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Library for functional reactive programming (FRP).
--   
--   Reactive-banana is a library for Functional Reactive Programming
--   (FRP).
--   
--   FRP offers an elegant and concise way to express interactive programs
--   such as graphical user interfaces, animations, computer music or robot
--   controllers. It promises to avoid the spaghetti code that is all too
--   common in traditional approaches to GUI programming.
--   
--   See the project homepage
--   <a>http://wiki.haskell.org/Reactive-banana</a> for more detailed
--   documentation and examples.
--   
--   <i>Stability forecast.</i> This is a stable library, though minor API
--   changes are still likely. It features an efficient, push-driven
--   implementation and has seen some optimization work.
--   
--   <i>API guide.</i> Start with the <a>Reactive.Banana</a> module.
@package reactive-banana
@version 1.1.0.1

module Reactive.Banana.Prim.Cached
data Cached m a
runCached :: Cached m a -> m a

-- | An action whose result will be cached. Executing the action the first
--   time in the monad will execute the side effects. From then on, only
--   the generated value will be returned.
cache :: (MonadFix m, MonadIO m) => m a -> Cached m a

-- | Return a pure value. Doesn't make use of the cache.
fromPure :: Monad m => a -> Cached m a

-- | Lift an action that is <i>not</i> cached, for instance because it is
--   idempotent.
don'tCache :: Monad m => m a -> Cached m a
liftCached1 :: (MonadFix m, MonadIO m) => (a -> m b) -> Cached m a -> Cached m b
liftCached2 :: (MonadFix m, MonadIO m) => (a -> b -> m c) -> Cached m a -> Cached m b -> Cached m c

module Reactive.Banana.Prim
type Step = EvalNetwork (IO ())

-- | A <a>Network</a> represents the state of a pulse/latch network,
data Network
emptyNetwork :: Network
type Build = ReaderWriterIOT BuildR BuildW IO
liftIOLater :: IO () -> Build ()
type BuildIO = Build
liftBuild :: Build a -> BuildIO a
buildLater :: Build () -> Build ()

-- | Pretend to return a value right now, but do not actually calculate it
--   until later.
--   
--   NOTE: Accessing the value before it's written leads to an error.
--   
--   FIXME: Is there a way to have the value calculate on demand?
buildLaterReadNow :: Build a -> Build a

-- | Change a <a>Network</a> of pulses and latches by executing a
--   <a>BuildIO</a> action.
compile :: BuildIO a -> Network -> IO (a, Network)

-- | Simple interpreter for pulse/latch networks.
--   
--   Mainly useful for testing functionality
--   
--   Note: The result is not computed lazily, for similar reasons that the
--   <a>sequence</a> function does not compute its result lazily.
interpret :: (Pulse a -> BuildIO (Pulse b)) -> [Maybe a] -> IO [Maybe b]

-- | <tt>mapAccum</tt> for a monad.
mapAccumM :: Monad m => (a -> s -> m (b, s)) -> s -> [a] -> m [b]

-- | Strict <tt>mapAccum</tt> for a monad. Discards results.
mapAccumM_ :: Monad m => (a -> s -> m (b, s)) -> s -> [a] -> m ()

-- | Execute an FRP network with a sequence of inputs. Make sure that
--   outputs are evaluated, but don't display their values.
--   
--   Mainly useful for testing whether there are space leaks.
runSpaceProfile :: Show b => (Pulse a -> BuildIO (Pulse b)) -> [a] -> IO ()

-- | Create a new pulse in the network and a function to trigger it.
--   
--   Together with <a>addHandler</a>, this function can be used to operate
--   with pulses as with standard callback-based events.
newInput :: Build (Pulse a, a -> Step)

-- | Register a handler to be executed whenever a pulse occurs.
--   
--   The pulse may refer to future latch values.
addHandler :: Pulse (Future a) -> (a -> IO ()) -> Build ()

-- | Read the value of a <a>Latch</a> at a particular moment in time.
readLatch :: Latch a -> Build a
type Pulse a = Ref (Pulse' a)

-- | <a>Pulse</a> that never fires.
neverP :: Build (Pulse a)
alwaysP :: Build (Pulse ())
mapP :: (a -> b) -> Pulse a -> Build (Pulse b)
type Future = IO

-- | Tag a <a>Pulse</a> with future values of a <a>Latch</a>.
--   
--   This is in contrast to <a>applyP</a> which applies the current value
--   of a <a>Latch</a> to a pulse.
tagFuture :: Latch a -> Pulse b -> Build (Pulse (Future a))
unsafeMapIOP :: (a -> IO b) -> Pulse a -> Build (Pulse b)
filterJustP :: Pulse (Maybe a) -> Build (Pulse a)
unionWithP :: (a -> a -> a) -> Pulse a -> Pulse a -> Build (Pulse a)
type Latch a = Ref (Latch' a)
pureL :: a -> Latch a
mapL :: (a -> b) -> Latch a -> Latch b
applyL :: Latch (a -> b) -> Latch a -> Latch b
accumL :: a -> Pulse (a -> a) -> Build (Latch a, Pulse a)
applyP :: Latch (a -> b) -> Pulse a -> Build (Pulse b)
switchL :: Latch a -> Pulse (Latch a) -> Build (Latch a)
executeP :: Pulse (b -> Build a) -> b -> Build (Pulse a)
switchP :: Pulse (Pulse a) -> Build (Pulse a)

module Reactive.Banana.Model

-- | Natural numbers (poorly represented).
type Nat = Int

-- | The FRP model used in this library is actually a model with continuous
--   time.
--   
--   However, it can be shown that this model is observationally equivalent
--   to a particular model with (seemingly) discrete time steps, which is
--   implemented here. The main reason for doing this is to be able to
--   handle recursion correctly. Details will be explained elsewhere.
type Time = Nat

-- | Event is modeled by an <i>infinite</i> list of <a>Maybe</a> values. It
--   is isomorphic to <tt>Time -&gt; Maybe a</tt>.
--   
--   <a>Nothing</a> indicates that no occurrence happens, while <a>Just</a>
--   indicates that an occurrence happens.
newtype Event a
E :: [Maybe a] -> Event a
[unE] :: Event a -> [Maybe a]

-- | Behavior is modeled by an <i>infinite</i> list of values. It is
--   isomorphic to <tt>Time -&gt; a</tt>.
newtype Behavior a
B :: [a] -> Behavior a
[unB] :: Behavior a -> [a]
interpret :: (Event a -> Moment (Event b)) -> [Maybe a] -> [Maybe b]
never :: Event a
unionWith :: (a -> a -> a) -> Event a -> Event a -> Event a
filterJust :: Event (Maybe a) -> Event a
apply :: Behavior (a -> b) -> Event a -> Event b
newtype Moment a
M :: (Time -> a) -> Moment a
[unM] :: Moment a -> Time -> a
accumE :: a -> Event (a -> a) -> Moment (Event a)
stepper :: a -> Event a -> Moment (Behavior a)
valueB :: Behavior a -> Moment a
observeE :: Event (Moment a) -> Event a
switchE :: Event (Event a) -> Moment (Event a)
switchB :: Behavior a -> Event (Behavior a) -> Moment (Behavior a)
instance GHC.Show.Show a => GHC.Show.Show (Reactive.Banana.Model.Behavior a)
instance GHC.Show.Show a => GHC.Show.Show (Reactive.Banana.Model.Event a)
instance GHC.Base.Functor Reactive.Banana.Model.Event
instance GHC.Base.Functor Reactive.Banana.Model.Behavior
instance GHC.Base.Applicative Reactive.Banana.Model.Behavior
instance GHC.Base.Functor Reactive.Banana.Model.Moment
instance GHC.Base.Applicative Reactive.Banana.Model.Moment
instance GHC.Base.Monad Reactive.Banana.Model.Moment
instance Control.Monad.Fix.MonadFix Reactive.Banana.Model.Moment

module Control.Event.Handler

-- | An <i>event handler</i> is a function that takes an <i>event value</i>
--   and performs some computation.
type Handler a = a -> IO ()

-- | The type <a>AddHandler</a> represents a facility for registering event
--   handlers. These will be called whenever the event occurs.
--   
--   When registering an event handler, you will also be given an action
--   that unregisters this handler again.
--   
--   <pre>
--   do unregisterMyHandler &lt;- register addHandler myHandler
--   </pre>
newtype AddHandler a
AddHandler :: (Handler a -> IO (IO ())) -> AddHandler a
[register] :: AddHandler a -> Handler a -> IO (IO ())

-- | Build a facility to register and unregister event handlers. Also
--   yields a function that takes an event handler and runs all the
--   registered handlers.
--   
--   Example:
--   
--   <pre>
--   do
--       (addHandler, fire) &lt;- newAddHandler
--       register addHandler putStrLn
--       fire "Hello!"
--   </pre>
newAddHandler :: IO (AddHandler a, Handler a)

-- | Map the event value with an <a>IO</a> action.
mapIO :: (a -> IO b) -> AddHandler a -> AddHandler b

-- | Filter event values that don't return <a>True</a>.
filterIO :: (a -> IO Bool) -> AddHandler a -> AddHandler a
instance GHC.Base.Functor Control.Event.Handler.AddHandler

module Reactive.Banana.Combinators

-- | <tt>Event a</tt> represents a stream of events as they occur in time.
--   Semantically, you can think of <tt>Event a</tt> as an infinite list of
--   values that are tagged with their corresponding time of occurrence,
--   
--   <pre>
--   type Event a = [(Time,a)]
--   </pre>
--   
--   Each pair is called an <i>event occurrence</i>. Note that within a
--   single event stream, no two event occurrences may happen at the same
--   time.
--   
data Event a

-- | <tt>Behavior a</tt> represents a value that varies in time.
--   Semantically, you can think of it as a function
--   
--   <pre>
--   type Behavior a = Time -&gt; a
--   </pre>
--   
data Behavior a

-- | Interpret an event processing function. Useful for testing.
--   
--   Note: You can safely assume that this function is pure, even though
--   the type seems to suggest otherwise. I'm really sorry about the extra
--   <a>IO</a>, but it can't be helped. See source code for the sordid
--   details.
interpret :: (Event a -> Moment (Event b)) -> [Maybe a] -> IO [Maybe b]

-- | Event that never occurs. Semantically,
--   
--   <pre>
--   never = []
--   </pre>
never :: Event a

-- | Merge two event streams of the same type. The function argument
--   specifies how event values are to be combined in case of a
--   simultaneous occurrence. The semantics are
--   
--   <pre>
--   unionWith f ((timex,x):xs) ((timey,y):ys)
--      | timex &lt;  timey = (timex,x)     : unionWith f xs ((timey,y):ys)
--      | timex &gt;  timey = (timey,y)     : unionWith f ((timex,x):xs) ys
--      | timex == timey = (timex,f x y) : unionWith f xs ys
--   </pre>
unionWith :: (a -> a -> a) -> Event a -> Event a -> Event a

-- | Allow all events that fulfill the predicate, discard the rest.
--   Semantically,
--   
--   <pre>
--   filterE p es = [(time,a) | (time,a) &lt;- es, p a]
--   </pre>
filterE :: (a -> Bool) -> Event a -> Event a

-- | Apply a time-varying function to a stream of events. Semantically,
--   
--   <pre>
--   apply bf ex = [(time, bf time x) | (time, x) &lt;- ex]
--   </pre>
--   
--   This function is generally used in its infix variant <a>&lt;@&gt;</a>.
apply :: Behavior (a -> b) -> Event a -> Event b

-- | The <a>Moment</a> monad denotes a <i>pure</i> computation that happens
--   at one particular moment in time. Semantically, it is a reader monad
--   
--   <pre>
--   type Moment a = Time -&gt; a
--   </pre>
--   
--   When run, the argument tells the time at which this computation
--   happens.
--   
--   Note that in this context, <i>time</i> really means to <i>logical
--   time</i>. Of course, every calculation on a computer takes some amount
--   of wall-clock time to complete. Instead, what is meant here is the
--   time as it relates to <a>Event</a>s and <a>Behavior</a>s. We use the
--   fiction that every calculation within the <a>Moment</a> monad takes
--   zero <i>logical time</i> to perform.
data Moment a

-- | An instance of the <a>MonadMoment</a> class denotes a computation that
--   happens at one particular moment in time. Unlike the <a>Moment</a>
--   monad, it need not be pure anymore.
class Monad m => MonadMoment m
liftMoment :: MonadMoment m => Moment a -> m a

-- | The <a>accumE</a> function accumulates a stream of event values,
--   similar to a <i>strict</i> left scan, <tt>scanl'</tt>. It starts with
--   an initial value and emits a new value whenever an event occurrence
--   happens. The new value is calculated by applying the function in the
--   event to the old value.
--   
--   Example:
--   
--   <pre>
--   accumE "x" [(time1,(++"y")),(time2,(++"z"))]
--       = trimE [(time1,"xy"),(time2,"xyz")]
--       where
--       trimE e start = [(time,x) | (time,x) &lt;- e, start &lt;= time]
--   </pre>
accumE :: MonadMoment m => a -> Event (a -> a) -> m (Event a)

-- | Construct a time-varying function from an initial value and a stream
--   of new values. The result will be a step function. Semantically,
--   
--   <pre>
--   stepper x0 ex = \time1 -&gt; \time2 -&gt;
--       last (x0 : [x | (timex,x) &lt;- ex, time1 &lt;= timex, timex &lt; time2])
--   </pre>
--   
--   Here is an illustration of the result Behavior at a particular time:
--   
--   
--   Note: The smaller-than-sign in the comparison <tt>timex &lt;
--   time2</tt> means that at time <tt>time2 == timex</tt>, the value of
--   the Behavior will still be the previous value. In the illustration,
--   this is indicated by the dots at the end of each step. This allows for
--   recursive definitions. See the discussion below for more on recursion.
stepper :: MonadMoment m => a -> Event a -> m (Behavior a)

-- | Obtain the value of the <a>Behavior</a> at a given moment in time.
--   Semantically, it corresponds to
--   
--   <pre>
--   valueB b = \time -&gt; b time
--   </pre>
--   
--   Note: The value is immediately available for pattern matching.
--   Unfortunately, this means that <tt>valueB</tt> is unsuitable for use
--   with value recursion in the <a>Moment</a> monad. If you need
--   recursion, please use <a>valueBLater</a> instead.
valueB :: MonadMoment m => Behavior a -> m a

-- | Obtain the value of the <a>Behavior</a> at a given moment in time.
--   Semantically, it corresponds to
--   
--   <pre>
--   valueBLater b = \time -&gt; b time
--   </pre>
--   
--   Note: To allow for more recursion, the value is returned <i>lazily</i>
--   and not available for pattern matching immediately. It can be used
--   safely with most combinators like <a>stepper</a>. If that doesn't work
--   for you, please use <a>valueB</a> instead.
valueBLater :: MonadMoment m => Behavior a -> m a

-- | Observe a value at those moments in time where event occurrences
--   happen. Semantically,
--   
--   <pre>
--   observeE e = [(time, m time) | (time, m) &lt;- e]
--   </pre>
observeE :: Event (Moment a) -> Event a

-- | Dynamically switch between <a>Event</a>. Semantically,
--   
--   <pre>
--   switchE ee = \time0 -&gt; concat [trim t1 t2 e | (t1,t2,e) &lt;- intervals ee, time0 &lt;= t1]
--       where
--       intervals e        = [(time1, time2, x) | ((time1,x),(time2,_)) &lt;- zip e (tail e)]
--       trim time1 time2 e = [x | (timex,x) &lt;- e, time1 &lt; timex, timex &lt;= time2]
--   </pre>
switchE :: MonadMoment m => Event (Event a) -> m (Event a)

-- | Dynamically switch between <a>Behavior</a>. Semantically,
--   
--   <pre>
--   switchB b0 eb = \time0 -&gt; \time1 -&gt;
--      last (b0 : [b | (timeb,b) &lt;- eb, time0 &lt;= timeb, timeb &lt; time1]) time1
--   </pre>
switchB :: MonadMoment m => Behavior a -> Event (Behavior a) -> m (Behavior a)

-- | Infix synonym for the <a>apply</a> combinator. Similar to
--   <a>&lt;*&gt;</a>.
--   
--   <pre>
--   infixl 4 &lt;@&gt;
--   </pre>
(<@>) :: Behavior (a -> b) -> Event a -> Event b
infixl 4 <@>

-- | Tag all event occurrences with a time-varying value. Similar to
--   <a>&lt;*</a>.
--   
--   <pre>
--   infixl 4 &lt;@
--   </pre>
(<@) :: Behavior b -> Event a -> Event b
infixl 4 <@

-- | Allow all event occurrences that are <a>Just</a> values, discard the
--   rest. Variant of <a>filterE</a>.
filterJust :: Event (Maybe a) -> Event a

-- | Allow all events that fulfill the time-varying predicate, discard the
--   rest. Generalization of <a>filterE</a>.
filterApply :: Behavior (a -> Bool) -> Event a -> Event a

-- | Allow events only when the behavior is <a>True</a>. Variant of
--   <a>filterApply</a>.
whenE :: Behavior Bool -> Event a -> Event a

-- | Split event occurrences according to a tag. The <a>Left</a> values go
--   into the left component while the <a>Right</a> values go into the
--   right component of the result.
split :: Event (Either a b) -> (Event a, Event b)

-- | Merge event streams whose values are functions. In case of
--   simultaneous occurrences, the functions at the beginning of the list
--   are applied <i>after</i> the functions at the end.
--   
--   <pre>
--   unions [] = never
--   unions xs = foldr1 (unionWith (.)) xs
--   </pre>
--   
--   Very useful in conjunction with accumulation functions like
--   <a>accumB</a> and <a>accumE</a>.
unions :: [Event (a -> a)] -> Event (a -> a)

-- | The <a>accumB</a> function accumulates event occurrences into a
--   <a>Behavior</a>.
--   
--   The value is accumulated using <a>accumE</a> and converted into a
--   time-varying value using <a>stepper</a>.
--   
--   Example:
--   
--   <pre>
--   accumB "x" [(time1,(++"y")),(time2,(++"z"))]
--      = stepper "x" [(time1,"xy"),(time2,"xyz")]
--   </pre>
--   
--   Note: As with <a>stepper</a>, the value of the behavior changes
--   "slightly after" the events occur. This allows for recursive
--   definitions.
accumB :: MonadMoment m => a -> Event (a -> a) -> m (Behavior a)

-- | Efficient combination of <a>accumE</a> and <a>accumB</a>.
mapAccum :: MonadMoment m => acc -> Event (acc -> (x, acc)) -> m (Event x, Behavior acc)

module Reactive.Banana.Frameworks

-- | Simple way to write a single event handler with functional reactive
--   programming.
interpretAsHandler :: (Event a -> Moment (Event b)) -> AddHandler a -> AddHandler b

-- | Compile the description of an event network into an
--   <a>EventNetwork</a> that you can <a>actuate</a>, <a>pause</a> and so
--   on.
compile :: MomentIO () -> IO EventNetwork

-- | The <a>MomentIO</a> monad is used to add inputs and outputs to an
--   event network.
data MomentIO a

-- | Input, obtain an <a>Event</a> from an <a>AddHandler</a>.
--   
--   When the event network is actuated, this will register a callback
--   function such that an event will occur whenever the callback function
--   is called.
fromAddHandler :: AddHandler a -> MomentIO (Event a)

-- | Input, obtain a <a>Behavior</a> from an <a>AddHandler</a> that
--   notifies changes.
--   
--   This is essentially just an application of the <a>stepper</a>
--   combinator.
fromChanges :: a -> AddHandler a -> MomentIO (Behavior a)

-- | Input, obtain a <a>Behavior</a> by frequently polling mutable data,
--   like the current time.
--   
--   The resulting <a>Behavior</a> will be updated on whenever the event
--   network processes an input event.
--   
--   This function is occasionally useful, but the recommended way to
--   obtain <tt>Behaviors</tt> is by using <a>fromChanges</a>.
--   
--   Ideally, the argument IO action just polls a mutable variable, it
--   should not perform expensive computations. Neither should its side
--   effects affect the event network significantly.
fromPoll :: IO a -> MomentIO (Behavior a)

-- | Output. Execute the <a>IO</a> action whenever the event occurs.
--   
--   Note: If two events occur very close to each other, there is no
--   guarantee that the <tt>reactimate</tt>s for one event will have
--   finished before the ones for the next event start executing. This does
--   <i>not</i> affect the values of events and behaviors, it only means
--   that the <tt>reactimate</tt> for different events may interleave.
--   Fortunately, this is a very rare occurrence, and only happens if
--   
--   <ul>
--   <li>you call an event handler from inside <a>reactimate</a>,</li>
--   <li>or you use concurrency.</li>
--   </ul>
--   
--   In these cases, the <tt>reactimate</tt>s follow the control flow of
--   your event-based framework.
--   
--   Note: An event network essentially behaves like a single, huge
--   callback function. The <a>IO</a> action are not run in a separate
--   thread. The callback function will throw an exception if one of your
--   <a>IO</a> actions does so as well. Your event-based framework will
--   have to handle this situation.
reactimate :: Event (IO ()) -> MomentIO ()

-- | The <a>Future</a> monad is just a helper type for the <tt>changes</tt>
--   function.
--   
--   A value of type <tt>Future a</tt> is only available in the context of
--   a <tt>reactimate</tt> but not during event processing.
data Future a

-- | Output. Execute the <a>IO</a> action whenever the event occurs.
--   
--   This version of <a>reactimate</a> can deal with values obtained from
--   the <a>changes</a> function.
reactimate' :: Event (Future (IO ())) -> MomentIO ()

-- | Output, return an <a>Event</a> that is adapted to the changes of a
--   <a>Behavior</a>.
--   
--   Remember that semantically, a <a>Behavior</a> is a function
--   <tt>Behavior a = Time -&gt; a</tt>. This means that a Behavior does
--   not have a notion of "changes" associated with it. For instance, the
--   following Behaviors are equal:
--   
--   <pre>
--   stepper 0 []
--   = stepper 0 [(time1, 0), (time2, 0)]
--   = stepper 0 $ zip [time1,time2..] (repeat 0)
--   </pre>
--   
--   In principle, to perform IO actions with the value of a Behavior, one
--   has to sample it using an <a>Event</a> and the <a>apply</a> function.
--   
--   However, in practice, Behaviors are usually step functions. For
--   reasons of efficiency, the library provides a way to obtain an Event
--   that <i>mostly</i> coincides with the steps of a Behavior, so that
--   sampling is only done at a few select points in time. The idea is that
--   
--   <pre>
--   changes =&lt;&lt; stepper x e  =  return e
--   </pre>
--   
--   Please use <a>changes</a> only in a ways that do <i>not</i>
--   distinguish between the different expressions for the same Behavior
--   above.
--   
--   Note that the value of the event is actually the <i>new</i> value,
--   i.e. that value slightly after this point in time. (See the
--   documentation of <a>stepper</a>). This is more convenient. However,
--   the value will not become available until after event processing is
--   complete; this is indicated by the type <a>Future</a>. It can be used
--   only in the context of <a>reactimate'</a>.
changes :: Behavior a -> MomentIO (Event (Future a))

-- | Impose a different sampling event on a <a>Behavior</a>.
--   
--   The <a>Behavior</a> will have the same values as before, but the event
--   returned by the <a>changes</a> function will now happen simultaneously
--   with the imposed event.
--   
--   Note: This function is useful only in very specific circumstances.
imposeChanges :: Behavior a -> Event () -> Behavior a

-- | Dynamically add input and output to an existing event network.
--   
--   Note: You can even do <a>IO</a> actions here, which is useful if you
--   want to register additional event handlers dynamically. However, there
--   is no guarantee about the order in which the actions are executed. If
--   the result <a>Event</a> of this function is garbage collected, it may
--   also happen that the actions are not executed at all. If you want a
--   reliable way to turn events into <a>IO</a> actions use the
--   <a>reactimate</a> and <a>reactimate'</a> functions.
execute :: Event (MomentIO a) -> MomentIO (Event a)

-- | Lift an <a>IO</a> action into the <a>Moment</a> monad, but defer its
--   execution until compilation time. This can be useful for recursive
--   definitions using <tt>MonadFix</tt>.
liftIOLater :: IO () -> MomentIO ()

-- | Interpret an event processing function by building an
--   <a>EventNetwork</a> and running it. Useful for testing, but uses
--   <a>MomentIO</a>. See <a>interpret</a> for a plain variant.
interpretFrameworks :: (Event a -> MomentIO (Event b)) -> [Maybe a] -> IO [Maybe b]

-- | Build an <a>Event</a> together with an <a>IO</a> action that can fire
--   occurrences of this event. Variant of <a>newAddHandler</a>.
--   
--   This function is mainly useful for passing callback functions inside a
--   <a>reactimate</a>.
newEvent :: MomentIO (Event a, Handler a)

-- | Build a new <a>Event</a> that contains the result of an IO
--   computation. The input and result events will <i>not</i> be
--   simultaneous anymore, the latter will occur <i>later</i> than the
--   former.
--   
--   Please use the <a>fmap</a> for <a>Event</a> if your computation is
--   pure.
--   
--   Implementation:
--   
--   <pre>
--   mapEventIO f e1 = do
--       (e2, handler) &lt;- newEvent
--       reactimate $ (\a -&gt; f a &gt;&gt;= handler) &lt;$&gt; e1
--       return e2
--   </pre>
mapEventIO :: (a -> IO b) -> Event a -> MomentIO (Event b)

-- | Build a <a>Behavior</a> together with an <a>IO</a> action that can
--   update this behavior with new values.
--   
--   Implementation:
--   
--   <pre>
--   newBehavior a = do
--       (e, fire) &lt;- newEvent
--       b         &lt;- stepper a e
--       return (b, fire)
--   </pre>
newBehavior :: a -> MomentIO (Behavior a, Handler a)

-- | Data type that represents a compiled event network. It may be paused
--   or already running.
data EventNetwork

-- | Actuate an event network. The inputs will register their event
--   handlers, so that the networks starts to produce outputs in response
--   to input events.
actuate :: EventNetwork -> IO ()

-- | Pause an event network. Immediately stop producing output. (In a
--   future version, it will also unregister all event handlers for
--   inputs.) Hence, the network stops responding to input events, but it's
--   state will be preserved.
--   
--   You can resume the network with <a>actuate</a>.
--   
--   Note: You can stop a network even while it is processing events, i.e.
--   you can use <a>pause</a> as an argument to <a>reactimate</a>. The
--   network will <i>not</i> stop immediately though, only after the
--   current event has been processed completely.
pause :: EventNetwork -> IO ()

module Reactive.Banana

-- | Compile the description of an event network into an
--   <a>EventNetwork</a> that you can <a>actuate</a>, <a>pause</a> and so
--   on.
compile :: MomentIO () -> IO EventNetwork
